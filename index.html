import os
import re
from flask import Flask, request, abort
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import MessageEvent, TextMessage, TextSendMessage

app = Flask(__name__)

# ç’°å¢ƒå¤‰æ•°
LINE_CHANNEL_ACCESS_TOKEN = os.environ.get('LINE_CHANNEL_ACCESS_TOKEN')
LINE_CHANNEL_SECRET = os.environ.get('LINE_CHANNEL_SECRET')

line_bot_api = LineBotApi(LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

# --- æ¨¡æ“¬ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ¬æ¥ã¯DBã‹ã‚‰å–å¾—ï¼‰ ---
# äºº1ã€œäºº20ã®3æ—¥åˆ†(20, 21, 22æ—¥)ã®ç©ºãçŠ¶æ³
availability_data = {
    f"äºº{i}": [0, 1, 0] if i % 2 == 0 else [1, 0, 0] for i in range(1, 21)
}
dates = ["20æ—¥", "21æ—¥", "22æ—¥"]

def solve_schedule(priorities, participants):
    """æœ€é©ãªæ—¥ç¨‹ã‚’è¨ˆç®—ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯"""
    scores = [0, 0, 0]
    for i in range(3):
        # å„ªå…ˆãƒ¡ãƒ³ãƒãƒ¼ãŒå…¨å“¡ç©ºã„ã¦ã„ã‚‹ã‹(0ãŒç©ºã)
        prio_ok = all(availability_data.get(p, [0,0,0])[i] == 0 for p in priorities)
        # å‚åŠ ãƒ¡ãƒ³ãƒãƒ¼ã®ç©ºãäººæ•°
        count = sum(1 for p in participants if availability_data.get(p, [0,0,0])[i] == 0)
        
        if prio_ok:
            scores[i] = count + 100 # å„ªå…ˆOKãªã‚‰å¤§å¹…åŠ ç‚¹
        else:
            scores[i] = count
            
    best_idx = scores.index(max(scores))
    return dates[best_idx], scores[best_idx] % 100

@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)
    return 'OK'

@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    text = event.message.text
    
    if "èª¿æ•´" in text:
        # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è§£æ
        range_match = re.search(r'æœŸé–“ï¼š(.+)', text)
        all_match = re.search(r'å‚åŠ ï¼š(.+)', text)
        prio_match = re.search(r'å„ªå…ˆï¼š(.+)', text)
        time_match = re.search(r'æ™‚é–“ï¼š(.+)', text)
        
        d_range = range_match.group(1) if range_match else "æœªæŒ‡å®š"
        participants = all_match.group(1).split(',') if all_match else []
        priorities = prio_match.group(1).split(',') if prio_match else []
        times = time_match.group(1).split(',') if time_match else []

        # æ—¥ç¨‹è¨ˆç®—ã®å®Ÿè¡Œ
        best_day, ok_count = solve_schedule(priorities, participants)

        # è¿”ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä½œæˆ
        res = f"ã€æ—¥ç¨‹èª¿æ•´ã®çµæœã€‘\n\n"
        res += f"ğŸ“… æŒ‡å®šæœŸé–“ï¼š\n{d_range}\n"
        res += f"ğŸ† ç¬¬ä¸€å€™è£œï¼š12æœˆ{best_day}\n"
        res += f"ğŸ‘¥ å‚åŠ å¯èƒ½ï¼š{ok_count}å\n"
        res += f"â° å¸Œæœ›æ™‚é–“ï¼š{', '.join(times)}\n\n"
        res += "â€»å„ªå…ˆãƒ¡ãƒ³ãƒãƒ¼ã¨å‚åŠ äººæ•°ã®ãƒãƒ©ãƒ³ã‚¹ã‹ã‚‰æœ€é©ãªæ—¥ã‚’ç®—å‡ºã—ã¾ã—ãŸã€‚"
        
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=res))

if __name__ == "__main__":
    app.run()